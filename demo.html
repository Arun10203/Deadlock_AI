<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Deadlock Detection - Live Demo</title>
    <style>
        body {
            background-color: #0c0c0c;
            color: #cccccc;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
            margin: 0;
            overflow-y: auto;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        .log-entry {
            margin-bottom: 5px;
            opacity: 0; /* Hidden initially for animation */
            animation: fadeIn 0.3s forwards;
        }
        .highlight { color: #f1f1f1; font-weight: bold; }
        .green { color: #4ade80; }
        .red { color: #f87171; }
        .blue { color: #22d3ee; }
        .yellow { color: #facc15; }
        .dim { color: #666; }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        #graph-container {
            margin-top: 30px;
            border: 2px solid #333;
            background: #111;
            display: none; /* Hidden until end */
            padding: 20px;
            text-align: center;
        }
        
        canvas {
            background-color: #1a1a1a;
            border-radius: 4px;
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background-color: #ccc;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }
    </style>
</head>
<body>

<div class="container">
    <div id="terminal-output"></div>
    <div id="graph-container">
        <h3 class="blue">Resource Allocation Graph (RAG)</h3>
        <canvas id="ragCanvas" width="600" height="400"></canvas>
        <p class="dim">Visualization generated by NetworkX simulation.</p>
    </div>
    <div class="cursor"></div>
</div>

<script>
    const outputDiv = document.getElementById('terminal-output');
    const graphDiv = document.getElementById('graph-container');
    const canvas = document.getElementById('ragCanvas');
    const ctx = canvas.getContext('2d');

    // Helper to print text with a slight delay
    function printLog(text, colorClass = '', delay = 0) {
        return new Promise(resolve => {
            setTimeout(() => {
                const div = document.createElement('div');
                div.className = 'log-entry ' + colorClass;
                div.innerHTML = text; // Allow HTML for bolding
                outputDiv.appendChild(div);
                window.scrollTo(0, document.body.scrollHeight);
                resolve();
            }, delay);
        });
    }

    async function runSimulation() {
        await printLog("user@os-sim:~$ python3 src/main.py --mode=live", "highlight", 500);
        await printLog("[System] Initializing OS Kernel...", "dim", 1000);
        await printLog("[System] Loading Resources: CPU (10), Memory (20)...", "", 800);
        await printLog("[AI Engine] Loading 'deadlock_model.pkl'...", "yellow", 1200);
        await printLog("[AI Engine] Model Loaded Successfully. Accuracy: 98%", "green", 1000);
        await printLog("------------------------------------------------", "dim", 500);
        await printLog("SYSTEM READY. LISTENING FOR REQUESTS...", "highlight", 1000);
        await printLog("<br>", "", 500);

        // Simulation Loop
        const events = [
            { pid: 101, res: "CPU", amt: 2, safe: true },
            { pid: 104, res: "Memory", amt: 5, safe: true },
            { pid: 102, res: "CPU", amt: 8, safe: false }, // Risky
            { pid: 101, res: "Memory", amt: 2, safe: true },
            { pid: 103, res: "CPU", amt: 1, safe: true },
            { pid: 105, res: "Memory", amt: 15, safe: false } // Risky
        ];

        for (let i = 0; i < events.length; i++) {
            let e = events[i];
            
            // 1. The Request
            await printLog(`[Request] Process <span class='highlight'>P${e.pid}</span> asks for ${e.amt} units of ${e.res}...`, "", 1000);
            
            // 2. Thinking
            await printLog(`&nbsp;&nbsp;...AI analyzing request pattern...`, "blue", 800);
            
            // 3. Decision
            if (e.safe) {
                await printLog(`&nbsp;&nbsp;-> [AI DECISION] <span class='green'>SAFE</span>. Request Granted.`, "", 600);
            } else {
                await printLog(`&nbsp;&nbsp;-> [AI DECISION] <span class='red'>RISK DETECTED</span>. Potential Deadlock! Blocked.`, "", 600);
            }
            await printLog("<br>", "", 500);
        }

        await printLog("[System] Simulation Complete.", "highlight", 1000);
        await printLog("[System] Generating Resource Allocation Graph...", "yellow", 1000);
        
        // Show Graph
        graphDiv.style.display = 'block';
        window.scrollTo(0, document.body.scrollHeight);
        drawGraph();
    }

    // Simple function to draw a fake Resource Allocation Graph on Canvas
    function drawGraph() {
        // Draw Nodes
        const nodes = [
            {x: 100, y: 100, label: "CPU", type: "res"},
            {x: 500, y: 100, label: "MEM", type: "res"},
            {x: 300, y: 300, label: "P101", type: "proc"},
            {x: 150, y: 250, label: "P104", type: "proc"},
            {x: 450, y: 250, label: "P103", type: "proc"}
        ];

        ctx.font = "14px Arial";
        ctx.lineWidth = 2;

        // Draw Edges first
        const edges = [
            {from: 2, to: 0}, // P101 -> CPU
            {from: 2, to: 1}, // P101 -> MEM
            {from: 3, to: 1}, // P104 -> MEM
            {from: 4, to: 0}  // P103 -> CPU
        ];

        edges.forEach(e => {
            ctx.beginPath();
            ctx.moveTo(nodes[e.from].x, nodes[e.from].y);
            ctx.lineTo(nodes[e.to].x, nodes[e.to].y);
            ctx.strokeStyle = "#555";
            ctx.stroke();
            
            // Arrowhead
            let angle = Math.atan2(nodes[e.to].y - nodes[e.from].y, nodes[e.to].x - nodes[e.from].x);
            ctx.beginPath();
            ctx.moveTo(nodes[e.to].x - 20 * Math.cos(angle - Math.PI / 6), nodes[e.to].y - 20 * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(nodes[e.to].x, nodes[e.to].y);
            ctx.lineTo(nodes[e.to].x - 20 * Math.cos(angle + Math.PI / 6), nodes[e.to].y - 20 * Math.sin(angle + Math.PI / 6));
            ctx.fillStyle = "#555";
            ctx.fill();
        });

        // Draw Nodes on top
        nodes.forEach(n => {
            ctx.beginPath();
            if(n.type === 'res') {
                ctx.rect(n.x - 25, n.y - 25, 50, 50);
                ctx.fillStyle = "#22d3ee";
            } else {
                ctx.arc(n.x, n.y, 30, 0, 2 * Math.PI);
                ctx.fillStyle = "#4ade80";
            }
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = "#000";
            ctx.fillText(n.label, n.type === 'res' ? n.x - 15 : n.x - 15, n.y + 5);
        });
        
        // Legend
        ctx.fillStyle = "#ccc";
        ctx.fillText("Green = Process, Blue = Resource", 20, 380);
    }

    // Start
    setTimeout(runSimulation, 1000);

</script>

</body>
</html>
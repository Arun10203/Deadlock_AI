import time
import random
import csv

class Resource:
    def __init__(self, name, total_instances):
        self.name = name
        self.total = total_instances
        self.available = total_instances
        self.allocated = 0

    def __repr__(self):
        return f"{self.name} (Available: {self.available}/{self.total})"

class Process:
    def __init__(self, pid, max_needs):
        self.pid = pid
        self.max_needs = max_needs
        self.allocated = {r: 0 for r in max_needs}
        self.finished = False

class OperatingSystem:
    def __init__(self):
        self.resources = {}
        self.processes = []
        # Prepare the CSV file for logging training data
        with open('deadlock_data.csv', 'w', newline='') as f:
            writer = csv.writer(f)
            # Columns: Feature 1 (Available), Feature 2 (Request), Target (Safe/Unsafe)
            writer.writerow(['Resource_Name', 'Available', 'Request_Amount', 'Is_Safe'])

    def add_resource(self, name, total_instances):
        self.resources[name] = Resource(name, total_instances)

    def add_process(self, pid, max_needs):
        self.processes.append(Process(pid, max_needs))

    def log_data(self, r_name, available, request, is_safe):
        with open('deadlock_data.csv', 'a', newline='') as f:
            writer = csv.writer(f)
            # 1 = Safe (Grant), 0 = Unsafe (Deny)
            label = 1 if is_safe else 0
            writer.writerow([r_name, available, request, label])

    def is_safe_state(self, process, resource_name, count):
        res = self.resources[resource_name]
        
        # LOGIC: If we grant this, will we drop below 0?
        # (In a real project, this is where the Complex Banker's Algorithm goes)
        if res.available >= count:
            return True
        return False

    def handle_request(self, process, resource_name, count):
        # 1. check state
        safe = self.is_safe_state(process, resource_name, count)
        
        # 2. Log this event for AI training
        current_avail = self.resources[resource_name].available
        self.log_data(resource_name, current_avail, count, safe)

        # 3. Execute
        if safe:
            self.resources[resource_name].available -= count
            process.allocated[resource_name] += count
            # print(f"  -> [Grant] Allocated {count} {resource_name} to Process {process.pid}")
            return True
        else:
            # print(f"  -> [Block] Process {process.pid} waiting for {resource_name}...")
            return False

def generate_training_data():
    """Runs a random simulation to create a dataset."""
    os_sim = OperatingSystem()
    os_sim.add_resource("CPU", 10)
    os_sim.add_resource("Memory", 20)
    
    # Create dummy processes
    for i in range(5):
        os_sim.add_process(i, {"CPU": 5, "Memory": 10})

    print("Generating training data...")
    # Simulate 1000 random requests
    for _ in range(1000):
        # Pick random process and resource
        p = random.choice(os_sim.processes)
        r_name = random.choice(["CPU", "Memory"])
        # Random request amount between 1 and 8
        amount = random.randint(1, 8)
        
        success = os_sim.handle_request(p, r_name, amount)
        
        # Occasionally release resources to keep simulation going
        if not success or random.random() < 0.3:
            # Fake release logic to reset availability for more data
            os_sim.resources[r_name].available += amount
            if os_sim.resources[r_name].available > os_sim.resources[r_name].total:
                os_sim.resources[r_name].available = os_sim.resources[r_name].total

    print("Data generation complete. Check 'deadlock_data.csv'.")

if __name__ == "__main__":
    generate_training_data()